<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
<body>
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Snake â€” Yellow (Fixed for Edge)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg: #081017; --cage: #ffd54f; --apple: #e53935; --obs: #ffb74d; }
    html,body { height:100%; margin:0; }
    body {
      display:flex; align-items:center; justify-content:center;
      background: linear-gradient(#0b1220,#071020); font-family:system-ui,Arial;
    }
    .wrap { display:flex; gap:18px; align-items:flex-start; }
    canvas { background: var(--bg); border:5px solid var(--cage); box-shadow:0 0 30px rgba(255,213,79,0.14); }
    .ui { color:#fff8d6; }
    .ui button { margin-top:8px; padding:8px 12px; border-radius:8px; border:none; background:#ffd54f; cursor:pointer; font-weight:700; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="600" height="600"></canvas>
    <div class="ui">
      <div>Score: <span id="score">0</span></div>
      <div style="margin-top:6px">Level: <span id="level">1</span></div>
      <div style="margin-top:10px; font-size:13px; color:#dcd0a8">Use Arrow keys to play.</div>
      <button id="startBtn">Start / Restart</button>
    </div>
  </div>

<script>
(() => {
  // --- constants ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const GRID = 20;
  const COLS = canvas.width / GRID;   // 30
  const ROWS = canvas.height / GRID;  // 30

  // UI elements
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const startBtn = document.getElementById('startBtn');

  // Game state
  let snake, dx, dy, apple, obstacles, score, level, speed;
  let intervalId = null;
  let running = false;
  let lastDir = 'RIGHT'; // prevent immediate reverse

  // Initialize state before starting
  function initState() {
    snake = [
      {x: 200, y: 200},
      {x: 180, y: 200},
      {x: 160, y: 200}
    ];
    dx = GRID; dy = 0;
    score = 0; level = 1; speed = 130;
    apple = spawnFreeCell();
    obstacles = [
      spawnFreeCell(),
      spawnFreeCell()
    ];
    running = false;
    lastDir = 'RIGHT';
    scoreEl.textContent = score;
    levelEl.textContent = level;
  }

  // Spawn in a free cell (not on snake or obstacles)
  function spawnFreeCell() {
    for (let tries=0; tries<1000; tries++) {
      const x = Math.floor(Math.random() * COLS) * GRID;
      const y = Math.floor(Math.random() * ROWS) * GRID;
      const onSnake = snake && snake.some(s => s.x === x && s.y === y);
      const onObs = obstacles && obstacles.some(o => o.x === x && o.y === y);
      if (!onSnake && !onObs) return {x,y};
    }
    // fallback
    return {x:0,y:0};
  }

  // Start or restart the interval loop safely
  function startGameLoop() {
    stopGameLoop();
    intervalId = setInterval(tick, speed);
    running = true;
  }

  function stopGameLoop() {
    if (intervalId !== null) {
      clearInterval(intervalId);
      intervalId = null;
    }
    running = false;
  }

  // Main tick
  function tick() {
    update();
    draw();
  }

  // Update: move snake, eat apple, level logic, collision check
  function update() {
    const head = { x: snake[0].x + dx, y: snake[0].y + dy };
    snake.unshift(head);

    // Eat apple?
    if (head.x === apple.x && head.y === apple.y) {
      score++;
      scoreEl.textContent = score;

      // level up every 5 points
      if (score % 5 === 0) {
        level++;
        levelEl.textContent = level;
        speed = Math.max(60, speed - 10);
        // add obstacle (ensure free)
        obstacles.push(spawnFreeCell());
        // restart loop with new speed
        if (running) {
          startGameLoop();
        }
      }
      apple = spawnFreeCell();
      // no pop => snake grows
    } else {
      snake.pop();
    }

    // collisions
    // wall
    if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
      endGame('You hit the wall!');
      return;
    }
    // self
    for (let i=1;i<snake.length;i++){
      if (snake[i].x === head.x && snake[i].y === head.y) {
        endGame('You ran into yourself!');
        return;
      }
    }
    // obstacles
    for (const o of obstacles) {
      if (o.x === head.x && o.y === head.y) {
        endGame('You hit an obstacle!');
        return;
      }
    }
  }

  // Draw everything
  function draw() {
    // background
    ctx.fillStyle = '#081017';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // cage border
    ctx.strokeStyle = '#ffd54f';
    ctx.lineWidth = 6;
    ctx.shadowColor = '#ffd54f';
    ctx.shadowBlur = 18;
    ctx.strokeRect(0,0,canvas.width,canvas.height);
    ctx.shadowBlur = 0;

    // obstacles
    ctx.fillStyle = '#ffb74d';
    for (const o of obstacles) {
      drawRoundedRect(o.x + 1, o.y + 1, GRID-2, GRID-2, 4, true, false);
    }

    // apple
    ctx.save();
    ctx.fillStyle = '#e53935';
    ctx.shadowColor = '#e53935';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(apple.x + GRID/2, apple.y + GRID/2, GRID/2 - 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    // highlight
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.fillRect(apple.x + 6, apple.y + 6, 6, 6);

    // snake (yellow gradient; head brighter)
    for (let i=snake.length-1;i>=0;i--) {
      const p = snake[i];
      const g = ctx.createLinearGradient(p.x, p.y, p.x + GRID, p.y + GRID);
      if (i===0) {
        g.addColorStop(0, '#fff8a6');
        g.addColorStop(1, '#e6c200');
      } else {
        g.addColorStop(0, '#ffe066');
        g.addColorStop(1, '#d4b100');
      }
      ctx.fillStyle = g;
      drawRoundedRect(p.x + 1, p.y + 1, GRID-2, GRID-2, 6, true, false);

      // head eyes & tongue
      if (i===0) drawHeadFeatures(p);
    }
  }

  // Draw head eyes and a small animated tongue
  let tongueLen = 0, tongueGrow = true;
  function drawHeadFeatures(head) {
    // eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(head.x + 6, head.y + 7, 3, 0, Math.PI*2);
    ctx.arc(head.x + 14, head.y + 7, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(head.x + 6, head.y + 7, 1.4, 0, Math.PI*2);
    ctx.arc(head.x + 14, head.y + 7, 1.4, 0, Math.PI*2);
    ctx.fill();

    // tongue animation update (simple)
    if (tongueGrow) { tongueLen += 1; if (tongueLen > 12) tongueGrow = false; }
    else { tongueLen -= 1; if (tongueLen < 2) tongueGrow = true; }

    // draw tongue depending on direction
    ctx.strokeStyle = '#e53935';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    if (dx > 0) { ctx.moveTo(head.x + GRID, head.y + GRID/2); ctx.lineTo(head.x + GRID + tongueLen, head.y + GRID/2); }
    else if (dx < 0) { ctx.moveTo(head.x, head.y + GRID/2); ctx.lineTo(head.x - tongueLen, head.y + GRID/2); }
    else if (dy > 0) { ctx.moveTo(head.x + GRID/2, head.y + GRID); ctx.lineTo(head.x + GRID/2, head.y + GRID + tongueLen); }
    else if (dy < 0) { ctx.moveTo(head.x + GRID/2, head.y); ctx.lineTo(head.x + GRID/2, head.y - tongueLen); }
    ctx.stroke();
  }

  // rounded rect helper (safe)
  function drawRoundedRect(x,y,w,h,r, fill=true, stroke=false) {
    const min = Math.min(w,h)/2;
    if (r>min) r=min;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function endGame(message) {
    stopGameLoop();
    setTimeout(() => {
      alert(message + '\nScore: ' + score);
      // show restart prompt
      // keep map visible; user may press Start/Restart
    }, 30);
    running = false;
  }

  // Key controls (prevent reverse)
  window.addEventListener('keydown', e => {
    const key = e.key;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(key)) e.preventDefault();
    if (key === 'ArrowUp' && dy === 0) { dx = 0; dy = -GRID; lastDir='UP'; }
    if (key === 'ArrowDown' && dy === 0) { dx = 0; dy = GRID; lastDir='DOWN'; }
    if (key === 'ArrowLeft' && dx === 0) { dx = -GRID; dy = 0; lastDir='LEFT'; }
    if (key === 'ArrowRight' && dx === 0) { dx = GRID; dy = 0; lastDir='RIGHT'; }
  });

  // Start/Restart button handler
  startBtn.addEventListener('click', () => {
    initState();
    draw(); // initial frame
    if (!running) startGameLoop();
  });

  // safe init & first frame
  initState();
  draw();

})();
</script>
<a href="index .html">index .html</a>
</body>
</html>
